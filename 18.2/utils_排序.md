# 1 冒泡排序
从后往前，相邻两个比较，把小的放在前面。数次循环直到最小的已经都在前面。【冒泡把小的值逐渐的冒到最前面，一轮确定一个最小】
```
for(int i=0;i<arr.length;i++){
    for(int j=arr.length-1;j>i;j--){
        if(arr[j-1]>arr[j]){
            swap(arr,j,j-1);
        }
    }
}
```
简单的改进是添加一个flag表示本次内循环中是否发生了swap，如果发生了则flag=true，而flag为false 的时候直接退出外循环，当前结果已经是最后结果。

本身有序则走一遍n就搞定，本身反序则(n-1)+(n-2)+...1=n(n-1)/2次
# 2 选择排序
遍历找到一个最小值，放到arr[0]，再在后n-1个元素遍历，选出最小放到arr[1]...
```
for(int i=0;i<arr.length;i++){
    for(int j=i+1;j<arr.length;j++){
        if(arr[j]<arr[i]){
            var t = arr[i]
            arr[i]=arr[j]
            arr[j]=t
        }
    }
}
```
# 3 插入排序
一个有序的序列，插入一个新值时，先和最后一个比较，如果大则直接放最后，如果小则和倒数第二个比，依次类推。是建立在一种原本是有序，后面插入新值的角度思考的。
```
//arr[0]是哨兵 实际排序没有这个值 有的算法中额外申请一个变量作为哨兵
for(int i>2; i<arr.length; i++){
    if(arr[i]<arr[i-1]){
        arr[0] = arr[i]
        for(j=i-1; arr[j]>arr[0];j--){
            arr[j+1]=arr[j]
        }
        arr[j+1]=arr[0]
    }
}
```
# 4 希尔排序
# 5 堆排序
利用存储结构堆，堆是一种完全二叉树，每个节点的孩子都比自己小，这就是大顶堆，反之小顶堆。用大顶堆存储数据，然后逐个弹出根节点，就是从大到小的顺序排列。
