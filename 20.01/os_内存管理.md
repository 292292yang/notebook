# 内存管理
# 写在最前
内存管理的要点简述：
- 程序看到的是逻辑地址，并不是真正的物理地址
- 内存需要进行分片，逻辑空间片叫page，物理空间的片叫page frame
- 逻辑-物理的page映射是放在page table（页表），其存在主存中
- 为了加速页表查询有了TLB（Translation Lookaside Buffer）快表
- 为了减小页表大小有了多级页表
- 为了程序本身便于管理内存有了分段
- 为了更好的使用cache有了VIPT
# 1 虚拟内存（逻辑内存）
虚拟内存其实有歧义，他可以指代两个东西：1 逻辑内存，2 映射到硬盘上的页。这里为了更好的区分，我们统一把前者叫做逻辑内存。

win32程序从程序上能操作的逻辑地址空间有4G这么大（虽然实际可能用不了那么多），4G的逻辑地址需要全部映射到物理内存上。映射的最小单位如果是字节的话，映射表将会非常大，且效率低下。提出page概念，即最小的映射单位是一个page，一页一般是4K，2M等这样的大小。

一种实际情况，4G逻辑地址有32bit地址空间，假设pageSize=4K偏移量占12bit，因而页表的逻辑页号有20bit。再假设实际内存条只有256G 28bit地址空间 12bit偏移量 16bit页号。

> 显然逻辑空间可能比实际要大，但是只要程序没有用那么多内存，就不需要去映射那么多page，且就算用了那么多内存，也可以映射到磁盘上。

逻辑地址`0x 00001 1a3`，去映射的时候00001就是逻辑页号，去查页表发现映射到真实页号0012，然后偏移量不变还是1a3，最终就找到这个物理内存内容了。

> 逻辑层的作用：极大的降低了内存随便；借助磁盘可以实现"无限的内存"；各个进程间内存的安全性等。
# 2 页表PT、快表TLB、多级页表
上面提到了逻辑-物理页的映射，这就是页表，但是上面的页表其实除了简单的页号映射，还存储了其他一些属性：是否有效，读写权限，修改位，访问位（淘汰算法和TLB中用），是否是脏（被修改过就是脏的，因为他和硬盘上的数据不一致），是否允许被高速缓存等等。

> 页表存于主存中，每个进程都有自己的页表。

上面可以看到基于页表的寻址，需要两次访问主存（页表是存在主存的），效率低下。为了提高速度，引入了快表，快表是页表项的缓存，将最近一次的映射项存入快表，因为空间有限所以需要逐出最老的那一项。快表的设计是基于经验：程序经常访问的page一般就那几个，不会经常频繁的更换特别多的页。

> 快表可能存于硬件MMU中（也可能是软件TLB），一般只有8-256条，每个进程都有自己的快表。

另一个值得讨论的话题是页表占用空间太大，上面例子中（32位程序256M机器pageSize4K）页号有20bit即2百万个，所以需要有1百万条，每条大小如果只算逻辑页号(20bit)和物理页号(16bit)的话：
```
36bit * 2^20 = 大约4MB（1/64总内存）
```
如果有64个这样的程序在运行...后果可想而知。

一种很好的解决方法是多级页表，第一级页表用于寻找第二级页表的编号。`<20bit-16bit>`的单级映射可以改成`<10bit-10bit>`和`<10bit-6bit>`两级映射。此时占用内存为 
```
20bit * 2^10 + 16bit * 2^10 = 大约4KB
```
# 3 分段
上文中讲述的是从硬件级别管理内存的方式，但是在程序中为了更好的来运行，是需要进行分段的，分段是在逻辑空间就分好的。

以32位程序为例，在逻辑空间中最高的0xc0000000 - 0xffffffff这1G的内存是给内核留出的。剩余3G内存从低到高分别是Text、Data、Heap、Lib、Stack。

Heap是从低往高增长，Stack是从高往低增长，且有个最大限制。Data存储静态变量Text存储程序二进制码，Lib存储库函数需要占用的内存，多个程序如果都使用了相同的库，内存是共用的（共享内存）。各个部分的留有随机的一段偏移量，可以保护程序，这也使得每次执行程序的时候变量所在的内存地址总是不同的。

> 分段是逻辑空间上的，后面进行分页，映射到物理内存上各部分跨多个页其实并不连续。
# 4 cache
cpu的三级缓存扮演着缓存主存数据的作用，而cache在内存管理中的位置是怎样的呢？

物理级cache，cpu分析完映射关系，先到cache找有没有该物理地址的cache。这样会非常的慢，但是所有进程可以共享cache。

逻辑级cache，cpu直接通过逻辑地址找cache，miss后再查TLB页表这些。这样很快，但是逻辑地址只能对当期进程使用，其他进程完全不能复用，尤其是库函数这种共享的不能利用好cache。


# 5 磁盘与缺页异常



