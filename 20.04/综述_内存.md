# 内存
本文系统的聊一聊内存的方方面面，后面有新的内容会补充上来。
# 操作系统的内存管理
这个在之前的文章中讲过，这里简单讲，详情可以[参考](../20.01/os_内存管理.md)。

## 1.1 基础： 虚拟内存 物理内存 页表
`虚拟内存`地址是指一个程序认为自己能操作的内存地址，虚拟内存地址的个数取决于操作系统是32位还是64位，32位能操作4G个地址，每个地址存储1Byte数据，因而32位程序认为自己能操作4GB内存空间。64位则是2^34GB，估计我有生也不会有这么大内存的PC。

`物理内存`是指内存条，64位系统能操作的内存非常大，但是实际上可能只有8GB的内存条。程序中看到的是虚拟内存，实际需要寻址映射到物理内存。每个字节都映射效率太低，映射表也需要非常大，所以提出了分页，假设页大小4K(常见大小)，就是虚拟内存每4K空间与物理内存4K进行映射。

`页表`就是来存储这个映射关系的，为了区分物理内存和虚拟内存的页，我们把物理内存的页暂时叫做帧。页表就是将页号映射成帧号或者映射到磁盘。

**重点：**  
因为虚拟内存可能远远大于物理内存，我们可以启动申请10G内存的java程序，而此时我们的操作系统能用的内存可能只有8G。另外的2G是在页表中是映射到磁盘的。当真正需要8G以上的内存的时候，就会映射到磁盘，此时会触发缺页中断（或叫缺页异常）从用户态进入内核态，操作系统运用页置换算法，将不咋用得到的内存帧置换到磁盘，将这部分帧给我们的这个程序来使用，并更新页表。

**细节：**
- 页号数量大于帧号数量，会使页表中页号可能是10位数，帧号可能是5位数
- 缺页中断是触发从用户态进入内核态，触发用户->内核的情况是中断、异常和系统调用
- 一个内存地址内的"住户"是一个字节而不是一个比特
- 页表存在主存中，而不是cpu或者特殊硬件 

![image](https://bolg.obs.cn-north-1.myhuaweicloud.com/2001/mem3.png)

## 1.2 优化：多级页表、快表、cpu缓存
页表占用空间很大，为了解决空间问题，有了多级页表，一级页表记录二级页表的位置，依次类推。多级页表可以有效地节省空间。

快表TLB，页表存于主存中，内存寻址需要两次访问主存，时间较长。为了解决时间问题，有了快表。每个进程有个快表，快表在cpu中特殊硬件，容量很小。快表记录进程最常访问的页的映射关系，是对页表中热点的缓存。快表可以有效地解决时间问题。

cpu缓存，常见的策略有
- PIPT，物理内存缓存，是查页表映射到物理内存时，先查下cache中有没有缓存。坏处是非常慢，前期都没有加速，好处就是进程可以共享了。
- VIVT，虚拟内存缓存，是查页表之前就先看cache是不是有存了，好处是非常快，坏处是每个进程的逻辑地址都是独立的，进程间不能共享。
- VIPT，将两者结合，用逻辑地址查找cache，cache中数据部分前面添加一个对应物理地址的tag。这样拿到这个tag后到tlb、页表中查看下这个对应关系是否正确，如果正确就直接读cache。这样速度和共享性都是折中的。

# 2 java中的内存
java内存其实之前也有比较详细的描述[jvm内存模型](../18.9/jvm_内存模型)，这里还是做下综述。

## 2.1 jvm内存各区
- `堆` 主要存储新对象、常亮区从jdk7开始也移到了堆中。
- `栈` 主要是函数运行存储局部的变量，存储单位是栈帧。一般是存储基础数据类型和对象的引用。
- `方法区` jdk8之后方法区位于元空间，使用的是操作系统内存。
- `本地方法栈` C++程序的栈。
- `程序计数器` 记录当前函数执行位置。

栈、本地栈、计数器都是线程私有的。栈上有时候也能分配对象，需要满足对象大小不能太大，逃逸分析后发现没有逃出当前栈等条件。
## 2.2 java对象的大小
java对象由对象头、内容和填充3部分构成，而对象头由三部分构成：
- Mark Word(32bits)    当前对象一些运行时数据如锁
- Klass Word(32bits)   类型指针，指向类对象（不是自己的地址）
- array length(32bits) 数组对象才有
对象头详情可以[参考](https://www.jianshu.com/p/3d38cba67f8b)

填充是指对象大小必须是8Byte的倍数，如果不是则进行填充。8字节是可以调整的通过-XX:ObjectAlignmentInBytes 参数。

java中64位系统下，堆内存小于32G的时候，是默认开启指针压缩的，也就是一个对象的地址可以用32bit(4字节)表示，而不是8字节。对象的地址开了压缩，同理原空间的类对象地址也需要开启压缩。
```
https://stuefe.de/posts/metaspace/what-is-compressed-class-space/

Compressed Object Pointers (“CompressedOops”) and Compressed Class Pointers. Both are variants of the same thing.
```
这是怎么做到的呢？因为对象8字节对齐，所以我们只需要记录当前对象起始地址是第几个8字节。32GB是2^35，8字节是2^3，所以32GB内存最多容纳2^32个8字节，换句话说32G最多放2^32个对象，所以地址只需要2^32个，因而用4字节就可以标识每个对象的地址了。

但是超过32G的堆的java进程就不行了，只能使用更多的字节来表示地址了，一般是8字节。所以会遇到33G的堆反而没有32G堆的java进程能用的内存多。

## 2.3 元空间

# 3 
